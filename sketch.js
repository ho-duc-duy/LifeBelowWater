// Released under GPL3. More information: https://www.gnu.org/licenses/gpl-3.0.en.html
// References for inspiration:
// Interactive Ripple Grid – CodePen by VoXelo – https://codepen.io/VoXelo/pen/LEYaMbJ
// “p5.js Spiral Wave Pattern” – YouTube: https://www.youtube.com/watch?v=zR5onrdWCeY

// --- Visual & Animation Settings ---
let baseHue;          // The base hue for the background and other colors, randomized on start.
let ellipses = [];      // An array to store the data for each concentric ring (radius, dash count, etc.).
let center;           // A p5.Vector object to store the center coordinates of the canvas.
let rotationSpeed;    // The speed at which the entire pattern rotates. Randomized on start.
let inwardSpeed;      // The speed at which the rings move towards the center. Randomized on start.
let maxRadius = 0;    // Stores the largest radius, used to reset rings when they reach the center.

// --- Audio Objects & State ---
let twistAudio;       // The audio object for the main looping animation sound (randomly chosen).
let ambienceAudio;    // The audio object for the secondary ambient background sound.
let hoverSfxAudio;    // The audio object for the sound when the mouse moves over the canvas.
let clickSfxAudio;    // The audio object for the UI button click sound.
let clickCanvasAudio; // The audio object for when the user clicks on the canvas itself.

// --- State Flags ---
let ambienceStarted = false; // Tracks if the main ambience has started playing.
let hoverActive = false;     // Tracks if the hover sound is currently playing.
let hoverTimeout;            // A timer to stop the hover sound when the mouse stops moving.
let isSfxEnabled = false;    // The main toggle for whether any sounds should play.

// --- Ripple Animation Data ---
let rippleOffsets = []; // A 2D array storing the hover displacement for each individual dash.
let clickRipples = [];  // An array storing active ripple data generated by mouse clicks.


//=================================================================
// SETUP FUNCTION
//=================================================================
// This function runs only once when the sketch is first loaded.
// It initializes the canvas, sets up initial variables, loads assets, and creates listeners.
function setup() {
  // Create a p5.js canvas with a resolution of 1920x1080.
  let canvas = createCanvas(1920, 1080);
  // Attach the canvas to the HTML element with the id 'canvas-container'.
  canvas.parent('canvas-container');

  // Set p5.js to use HSB (Hue, Saturation, Brightness) color mode for more intuitive color manipulation.
  colorMode(HSB, 360, 100, 100);
  // Tell p5.js not to fill any shapes with color by default.
  noFill();
  // Initialize the base hue to a random blueish color.
  baseHue = random(200, 220);
  // Calculate and store the center of the canvas.
  center = createVector(width / 2, height / 2);

  // Set the animation speeds to small random values for a slow, hypnotic effect.
  rotationSpeed = random(-0.001, 0.001);
  inwardSpeed = random(0.1, 0.3);

  // This loop generates the data for each concentric ellipse ring. It doesn't draw anything yet.
  for (let r = 50; r < min(width, height); r += 30) {
    ellipses.push({
      radius: r,                        // The initial radius of the ring.
      dashCount: int(random(5, 100)),   // A random number of dashes for this ring.
      strokeWeight: random(1, 4),       // A random thickness for the dashes.
      color: color(0, 0, 60),           // The default greyish color for the dashes.
    });
    // Keep track of the largest starting radius to use for resetting rings.
    if (r > maxRadius) {
      maxRadius = r;
    }
  }

  // This loop creates a parallel array to 'ellipses' to store the individual hover offset for each dash.
  // Each dash starts with an offset of 0.
  for (let e of ellipses) {
    rippleOffsets.push(new Array(e.dashCount).fill(0));
  }

  // --- Audio Initialization ---
  // Load and configure all the audio files. 'loop = true' makes them repeat.
  ambienceAudio = new Audio('assets/COMM2754-2025-S2-A2w08-LifeBelowWater-ambience.wav');
  ambienceAudio.loop = true;
  ambienceAudio.volume = 0.3;
  hoverSfxAudio = new Audio('assets/COMM2754-2025-S2-A2w08-LifeBelowWater-hover.wav');
  hoverSfxAudio.loop = true;
  hoverSfxAudio.volume = 0.6;
  clickSfxAudio = new Audio('assets/COMM2754-2025-S2-A2w08-LifeBelowWater-click.wav');
  clickCanvasAudio = new Audio('assets/COMM2754-2025-S2-A2w08-LifeBelowWater-clickcanvas.wav');
  clickCanvasAudio.volume = 0.7;
  
  // --- Random Looping Sound Logic ---
  // 1. Create an array holding the file paths of the two possible looping sounds.
  const loopingSoundPaths = [
    'assets/COMM2754-2025-S2-A2w08-LifeBelowWater-twist.wav',
    'assets/COMM2754-2025-S2-A2w08-LifeBelowWater-marineloop.wav'
  ];
  // 2. Use the p5.js random() function to pick one of the paths from the array.
  let chosenSoundPath = random(loopingSoundPaths);
  // 3. Initialize the main 'twistAudio' object using the randomly selected sound file.
  twistAudio = new Audio(chosenSoundPath);
  twistAudio.loop = true;
  twistAudio.volume = 0.5;

  // --- Final Setup Calls ---
  // Call other functions to set up the interactive HTML elements and event listeners.
  setupSfxButton();
  setupBubbles();
  window.addEventListener('scroll', handleScroll);
}


//=================================================================
// DRAW FUNCTION
//=================================================================
// It's responsible for updating animations and redrawing the canvas for each frame.
function draw() {
  // Clear the canvas and draw the dark blue background for this frame.
  background(baseHue, 80, 15);
  // Move the origin (0,0) from the top-left corner to the center of the canvas.
  // This simplifies calculations for circular patterns.
  translate(center.x, center.y);

  // --- Update and Animate Click Ripples ---
  // Loop through each active click ripple.
  for (let ripple of clickRipples) {
    ripple.radius += 20;     // Make the ripple expand.
    ripple.strength *= 0.9;  // Make the ripple's strength fade over time.
  }
  // Remove any ripples that have faded out to keep the array clean and improve performance.
  clickRipples = clickRipples.filter(r => r.strength > 0.01);

  // --- Animate Inward Flow of Rings ---
  // Loop through each ellipse ring and update its radius.
  for (let e of ellipses) {
    e.radius -= inwardSpeed; // Move the ring towards the center.
    // If a ring gets too close to the center, reset its position to the outside edge.
    if (e.radius < 50) {
      e.radius = maxRadius + random(0, 30);
    }
  }

  // --- Main Drawing Loop ---
  // This nested loop calculates the position of and draws every single dash for this frame.
  for (let eIndex = 0; eIndex < ellipses.length; eIndex++) {
    let e = ellipses[eIndex];
    strokeWeight(e.strokeWeight);
    let angleStep = TWO_PI / e.dashCount; // TWO_PI is a full circle (360 degrees in radians).

    for (let i = 0; i < e.dashCount; i++) {
      // Calculate the angle for this dash, including the continuous global rotation.
      let angle = (angleStep * i) + (frameCount * rotationSpeed);
      let dashRadius = e.radius;

      // Calculate the mouse position relative to the center of the canvas.
      let mx = mouseX - center.x;
      let my = mouseY - center.y;

      // Calculate the base (un-rippled) position of this dash.
      let baseX = cos(angle) * dashRadius;
      let baseY = sin(angle) * dashRadius;

      // Calculate the distance from the mouse to this dash.
      let d = dist(baseX, baseY, mx, my);
      
      // --- Apply Hover Ripple ---
      // If the mouse is close, smoothly push the dash outwards (a negative offset).
      if (d < 100) {
        // lerp() creates a smooth transition from the current offset towards -15.
        rippleOffsets[eIndex][i] = lerp(rippleOffsets[eIndex][i], -15, 0.2);
      } else {
        // If the mouse is far, smoothly return the dash to its original position (offset of 0).
        rippleOffsets[eIndex][i] = lerp(rippleOffsets[eIndex][i], 0, 0.1);
      }
      let offset = rippleOffsets[eIndex][i];

      // --- Apply Click Ripples ---
      // Check every active click ripple to see if it affects this dash.
      for (let ripple of clickRipples) {
        let dClick = dist(baseX, baseY, ripple.x, ripple.y);
        if (dClick < ripple.radius) {
          // If the dash is inside a click ripple, add to its offset to push it away.
          offset += map(dClick, 0, ripple.radius, -ripple.strength, 0);
        }
      }
      
      // The final radius is the ring's current radius plus all combined offsets.
      let finalRadius = dashRadius + offset;
      
      // Calculate the start (x,y) and end (x2,y2) points for the dash segment.
      let x = cos(angle) * finalRadius;
      let y = sin(angle) * finalRadius;
      let x2 = cos(angle + angleStep * 0.8) * finalRadius;
      let y2 = sin(angle + angleStep * 0.3) * finalRadius;
      
      // --- Set Dash Color ---
      // If the mouse is close, change the stroke color to a bright, random blue.
      if (d < 200) {
        stroke(random(200, 240), 80, 100);
      } else {
        // Otherwise, use the ring's default greyish color.
        stroke(e.color);
      }
      // Draw the final line segment for the dash.
      line(x, y, x2, y2);
    }
  }
}


//=================================================================
// DOM & INTERACTION FUNCTIONS
//=================================================================

// --- Decorative Bubbles Setup ---
// Creates and manages the floating bubble elements in the HTML background.
function setupBubbles() {
  const bubbleContainer = document.querySelector('.bubble-background');
  const bubbleCount = 20; // The total number of bubbles to create.

  // Create each bubble element individually.
  for (let i = 0; i < bubbleCount; i++) {
    const bubble = document.createElement('div');
    bubble.classList.add('bubble');
    
    // Assign random properties to each bubble for a natural, varied look.
    const size = Math.random() * 80 + 20;      // Random size.
    const duration = Math.random() * 10 + 10;  // Random animation duration.
    const delay = Math.random() * 15;          // Random start delay.

    // Apply the random properties via inline CSS styles.
    bubble.style.width = `${size}px`;
    bubble.style.height = `${size}px`;
    bubble.style.left = `${Math.random() * 100}%`;
    bubble.style.bottom = `${-size}px`;
    bubble.style.animationDuration = `${duration}s`;
    bubble.style.animationDelay = `${delay}s`;
    bubble.style.backgroundColor = 'rgba(0, 150, 255, 0.2)';

    // Add the newly created bubble to the page.
    bubbleContainer.appendChild(bubble);
  }
}

// --- Scroll Event Handler ---
// This function is called every time the user scrolls the page.
function handleScroll() {
  // Get references to the necessary HTML elements.
  const bubbleContainer = document.querySelector('.bubble-background');
  const bubbles = document.querySelectorAll('.bubble');
  const canvasContainer = document.getElementById('canvas-container');
  const canvasRect = canvasContainer.getBoundingClientRect(); // Gets the canvas's position on screen.

  // Create a parallax effect by moving the bubble container up at a slower rate than the scroll.
  bubbleContainer.style.transform = `translateY(${window.scrollY * 0.4}px)`;

  // Change the bubble color from blue to white as the user scrolls down to the dark canvas area.
  if (canvasRect.top < window.innerHeight / 2) { // When the canvas is halfway up the screen...
    bubbles.forEach(bubble => {
      bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.1)'; // ...turn bubbles white.
    });
  } else {
    bubbles.forEach(bubble => {
      bubble.style.backgroundColor = 'rgba(0, 150, 255, 0.2)'; // ...otherwise, keep them blue.
    });
  }
}

// --- Mouse Moved Handler ---
// This function is called every time the mouse moves.
function mouseMoved() {
  // Only proceed if sounds are enabled.
  if (isSfxEnabled) {
    // If the hover sound isn't already playing, start it.
    if (!hoverActive) {
      hoverActive = true;
      hoverSfxAudio.currentTime = 0; // Rewind to start.
      hoverSfxAudio.play().catch(e => console.warn('Hover sound failed:', e));
    }
    // Reset the timer. If the mouse keeps moving, this timer will never finish.
    clearTimeout(hoverTimeout);
    // Set a new timer. If the mouse stops for 200ms, the code inside will run.
    hoverTimeout = setTimeout(() => {
      hoverActive = false; // Mark the sound as inactive.
      hoverSfxAudio.pause(); // Stop the sound.
    }, 200);
  }
}

// --- Mouse Pressed Handler ---
// This function is called once whenever a mouse button is pressed.
function mousePressed() {
  // Check that the click occurred within the bounds of the p5.js canvas.
  if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
    // Get click coordinates relative to the canvas center.
    let cx = mouseX - center.x;
    let cy = mouseY - center.y;
    // Create a new ripple object and add it to the active ripples array.
    clickRipples.push({ x: cx, y: cy, radius: 0, strength: 80 });

    // If sounds are enabled, play the canvas click sound effect.
    if (isSfxEnabled) {
      clickCanvasAudio.currentTime = 0;
      clickCanvasAudio.play().catch(e => console.warn('Canvas click sound failed:', e));
    }
  }
}

// --- UI Click Sound Helper ---
// A small, reusable function to play the generic UI click sound.
function playClickSound() {
  clickSfxAudio.currentTime = 0;
  clickSfxAudio.play().catch(e => console.warn("Click SFX failed to play:", e));
}

// --- SFX Button Setup ---
// Sets up the event listener and logic for the main sound toggle button.
function setupSfxButton() {
  const sfxButton = document.getElementById('sfx-button');
  sfxButton.addEventListener('click', () => {
    playClickSound(); // Play the UI click sound.
    isSfxEnabled = !isSfxEnabled; // Flip the sound state (true to false, or false to true).

    // If sound is now ON:
    if (isSfxEnabled) {
      sfxButton.textContent = 'SFX: ON';
      sfxButton.classList.add('sfx-on');
      // Play the main background sounds.
      ambienceAudio.play().catch(e => console.error("Ambience play failed:", e));
      twistAudio.play().catch(e => console.error("Twist audio play failed:", e));
      ambienceStarted = true;
    // If sound is now OFF:
    } else {
      sfxButton.textContent = 'SFX: OFF';
      sfxButton.classList.remove('sfx-on');
      // Pause all background sounds.
      ambienceAudio.pause();
      hoverSfxAudio.pause();
      twistAudio.pause();
      // Reset the hover sound state.
      hoverActive = false;
      clearTimeout(hoverTimeout);
    }
  });
}
